name: Auto Upload Bot Bridge

on:
  workflow_dispatch:
    inputs:
      file_url:
        description: 'File URL from Telegram'
        required: true
      service:
        description: 'Destination service'
        required: true
      chat_id:
        description: 'Telegram Chat ID'
        required: true
      telegram_token:
        description: 'Bot Token from VPS'
        required: true
      pixeldrain_key:
        description: 'PixelDrain Key from VPS'
        required: true
      filename:
        description: 'Original filename'
        required: true
      file_type:
        description: 'File type (document/photo/video/link)'
        required: true
      message_id:
        description: 'Message ID for status updates'
        required: true

# Allow multiple workflows to run simultaneously - 1 file = 1 runner
concurrency:
  group: upload-${{ github.event.inputs.filename }}-${{ github.run_id }}
  cancel-in-progress: false

jobs:
  upload_and_notify:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours max per file
    
    steps:
      - name: Set Job Name
        run: echo "ðŸ“¤ Processing ${{ inputs.filename }}"

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Download File
        id: download
        run: |
          RAW_URL="${{ inputs.file_url }}"
          FILENAME="${{ inputs.filename }}"
          
          echo "ðŸ“¥ Downloading: $FILENAME"
          echo "ðŸ”— URL: $RAW_URL"
          
          # Clean double URLs if exists
          if [[ "$RAW_URL" == *"https://"*"https://"* ]]; then
             echo "ðŸ”§ Fixing double URL..."
             CLEAN_URL=$(python3 -c "import sys; u=sys.argv[1]; print('https://' + u.split('https://')[-1])" "$RAW_URL")
          else
             CLEAN_URL="$RAW_URL"
          fi
          
          echo "âœ… Final URL: $CLEAN_URL"
          
          # Download with original filename
          OUTPUT_FILE="/tmp/$FILENAME"
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "â¬ Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
            
            if curl -L --connect-timeout 30 --max-time 600 -o "$OUTPUT_FILE" "$CLEAN_URL"; then
              echo "âœ… Download successful!"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "âš ï¸ Download failed, retrying in 2s..."
                sleep 2
              fi
            fi
          done
          
          if [ ! -f "$OUTPUT_FILE" ]; then
            echo "âŒ Download failed after $MAX_RETRIES attempts"
            exit 1
          fi
          
          # Get file size
          FILE_SIZE=$(stat -f%z "$OUTPUT_FILE" 2>/dev/null || stat -c%s "$OUTPUT_FILE")
          FILE_SIZE_MB=$(echo "scale=2; $FILE_SIZE / 1024 / 1024" | bc)
          
          echo "ðŸ“Š File size: $FILE_SIZE bytes ($FILE_SIZE_MB MB)"
          echo "file_path=$OUTPUT_FILE" >> $GITHUB_OUTPUT
          echo "file_size_mb=$FILE_SIZE_MB" >> $GITHUB_OUTPUT

      - name: Upload to PixelDrain
        id: upload_pixeldrain
        if: inputs.service == 'pixeldrain'
        run: |
          pip install requests > /dev/null 2>&1
          
          PK="${{ inputs.pixeldrain_key }}"
          PK=$(echo "$PK" | xargs)  # Trim whitespace
          
          FILE="${{ steps.download.outputs.file_path }}"
          FILENAME="${{ inputs.filename }}"
          
          echo "â« Uploading to PixelDrain: $FILENAME"
          
          # Create upload script
          cat > /tmp/upload_script.py << 'EOFPYTHON'
import requests
import sys
import os

api_key = sys.argv[1]
file_path = sys.argv[2]
original_name = sys.argv[3]

try:
    print(f"ðŸ“¤ Starting upload: {original_name}")
    
    with open(file_path, 'rb') as f:
        files = {'file': (original_name, f)}
        response = requests.post(
            'https://pixeldrain.com/api/file/',
            auth=('', api_key),
            files=files,
            timeout=600
        )
    
    if response.status_code == 201:
        data = response.json()
        file_id = data.get('id', '')
        if file_id:
            print(f"SUCCESS|{file_id}")
            sys.exit(0)
        else:
            print(f"ERROR|No ID in response: {response.text}")
            sys.exit(1)
    else:
        print(f"ERROR|Status {response.status_code}: {response.text}")
        sys.exit(1)
        
except Exception as e:
    print(f"ERROR|Exception: {str(e)}")
    sys.exit(1)
EOFPYTHON
          
          # Execute upload
          RESULT=$(python3 /tmp/upload_script.py "$PK" "$FILE" "$FILENAME")
          
          if [[ "$RESULT" == SUCCESS* ]]; then
            ID="${RESULT#*|}"
            LINK="https://pixeldrain.com/u/$ID"
            echo "result_link=$LINK" >> $GITHUB_OUTPUT
            echo "service_name=PixelDrain" >> $GITHUB_OUTPUT
            echo "âœ… Upload successful: $LINK"
          else
            echo "âŒ Upload failed: $RESULT"
            exit 1
          fi

      - name: Upload to MediaFire (Mock)
        id: upload_mediafire
        if: inputs.service == 'mediafire'
        run: |
          echo "ðŸ”¥ Mocking MediaFire Upload..."
          echo "result_link=https://www.mediafire.com/file/dummy/${{ inputs.filename }}" >> $GITHUB_OUTPUT
          echo "service_name=MediaFire" >> $GITHUB_OUTPUT

      - name: Upload to Google Drive (Mock)
        id: upload_gdrive
        if: inputs.service == 'gdrive'
        run: |
          echo "â˜ï¸ Mocking Google Drive Upload..."
          echo "result_link=https://drive.google.com/file/d/dummy123/view" >> $GITHUB_OUTPUT
          echo "service_name=Google Drive" >> $GITHUB_OUTPUT

      - name: Send Result to Bot
        if: always()
        run: |
          TOKEN="${{ inputs.telegram_token }}"
          CHAT_ID="${{ inputs.chat_id }}"
          FILENAME="${{ inputs.filename }}"
          
          if [ "${{ job.status }}" == "success" ]; then
            if [ "${{ inputs.service }}" == "pixeldrain" ]; then
               LINK="${{ steps.upload_pixeldrain.outputs.result_link }}"
               SERVICE="${{ steps.upload_pixeldrain.outputs.service_name }}"
            elif [ "${{ inputs.service }}" == "mediafire" ]; then
               LINK="${{ steps.upload_mediafire.outputs.result_link }}"
               SERVICE="MediaFire"
            else
               LINK="${{ steps.upload_gdrive.outputs.result_link }}"
               SERVICE="Google Drive"
            fi
            
            # Send completion notification
            MSG="UPLOAD_COMPLETE|$FILENAME|$LINK|${{ steps.download.outputs.file_size_mb }}|$SERVICE"
          else
            MSG="UPLOAD_FAILED|$FILENAME"
          fi
          
          # Send via webhook format (bot will parse this)
          curl -s -X POST "https://api.telegram.org/bot$TOKEN/sendMessage" \
            -d chat_id=$CHAT_ID \
            -d text="__STATUS_UPDATE__:$MSG" \
            -d disable_notification=true
